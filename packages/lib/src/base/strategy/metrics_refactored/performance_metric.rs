use crate::base::{
    components::{component_context::ComponentContext, component_default::ComponentDefault},
    strategy::{
        strategy_component_context::StrategyComponentContext,
        strategy_execution_context::StrategyExecutionContext, trade_refactor::TradeDirection,
    },
};

use super::utils::{
    compute_avg_losing_trade, compute_avg_trade, compute_avg_win_loss_ratio,
    compute_avg_winning_trade, compute_long_net_profit_ratio, compute_percent_profitable_trades,
    compute_profit_factor,
};

#[derive(Debug, Clone, Copy)]
pub struct PerformanceMetric {
    pub net_profit_percent: f64,
    /// Total value of all completed winning trades. In TradingView `strategy.grossprofit`
    pub gross_profit: f64,
    pub gross_profit_percent: f64,
    /// Total value of all completed losing trades. In TradingView `strategy.grossloss`
    pub gross_loss: f64,
    pub gross_loss_percent: f64,
    pub long_net_profit: f64,
    pub long_net_profit_percent: f64,
    pub short_net_profit: f64,
    pub short_net_profit_percent: f64,
    pub long_short_net_profit_ratio: f64,
    pub profit_factor: f64,
    /// Total number of closed tradesIn TradingView `strategy.closedtrades`
    pub closed_trades: usize,
    /// Total number of winning tradesIn TradingView `strategy.wintrades`
    pub winning_trades: usize,
    /// Total number of losing tradesIn TradingView `strategy.losstrades
    pub losing_trades: usize,
    /// The percentage of winning trades generated by a strategy.
    pub percent_profitable: f64,
    /// The gross profit divided by the number of winning trades.
    pub avg_winning_trade: f64,
    /// The gross loss divided by the number of losing trades.
    pub avg_losing_trade: f64,
    /// The sum of money gained or lost by the average trade.
    pub avg_trade: f64,
    /// The average value of how many currency units you win for every unit you lose.
    pub avg_winning_losing_trade_ratio: f64,
}

impl ComponentDefault for PerformanceMetric {
    fn default(ctx: ComponentContext) -> Self {
        return Self {
            net_profit_percent: 0.0,
            gross_profit_percent: 0.0,
            gross_profit: 0.0,
            gross_loss_percent: 0.0,
            gross_loss: 0.0,
            long_net_profit: 0.0,
            long_net_profit_percent: 0.0,
            short_net_profit: 0.0,
            short_net_profit_percent: 0.0,
            long_short_net_profit_ratio: 0.0,
            profit_factor: 1.0,
            closed_trades: 0,
            winning_trades: 0,
            losing_trades: 0,
            percent_profitable: 0.0,
            avg_winning_trade: 0.0,
            avg_losing_trade: 0.0,
            avg_trade: 0.0,
            avg_winning_losing_trade_ratio: 0.0,
        };
    }
}

pub struct PerformanceMetricComponent {
    pub res: PerformanceMetric,
    ctx: ComponentContext,
    strategy_ctx: StrategyComponentContext,
    lowest_equity: f64,
    highest_equity: f64,
}

impl PerformanceMetricComponent {
    pub fn new(ctx: ComponentContext, strategy_ctx: StrategyComponentContext) -> Self {
        let initial_capital = strategy_ctx.get().config.initial_capital;
        return Self {
            ctx: ctx.clone(),
            strategy_ctx,
            res: PerformanceMetric::default(ctx.clone()),
            highest_equity: initial_capital,
            lowest_equity: initial_capital,
        };
    }

    pub fn next(&mut self) {
        self.ctx.on_next();

        let s = self.strategy_ctx.get();

        if let Some(e) = &s.events.on_trade_exit {
            let initial_capital = s.config.initial_capital;

            if e.trade.direction == TradeDirection::Long {
                self.res.long_net_profit += e.pnl;
            } else {
                self.res.short_net_profit += e.pnl;
            }

            if e.pnl > 0.0 {
                self.res.gross_profit += e.pnl;
                self.res.winning_trades += 1;
            } else if e.pnl < 0.0 {
                self.res.gross_loss += e.pnl.abs();
                self.res.losing_trades += 1;
            }

            self.res.net_profit_percent = s.net_profit / initial_capital;
            self.res.gross_profit_percent = self.res.gross_profit / initial_capital;
            self.res.gross_loss_percent = self.res.gross_loss / initial_capital;
            self.res.profit_factor =
                compute_profit_factor(self.res.gross_profit, self.res.gross_loss).unwrap_or(1.0);

            self.res.long_net_profit_percent = self.res.long_net_profit / initial_capital;
            self.res.short_net_profit_percent = self.res.short_net_profit / initial_capital;

            self.res.long_short_net_profit_ratio =
                compute_long_net_profit_ratio(self.res.long_net_profit, self.res.short_net_profit)
                    .unwrap_or(0.0);

            self.res.closed_trades += 1;

            self.res.percent_profitable =
                compute_percent_profitable_trades(self.res.winning_trades, self.res.closed_trades)
                    .unwrap_or(0.0);

            self.res.avg_trade =
                compute_avg_trade(s.net_profit, self.res.closed_trades).unwrap_or(0.0);
            self.res.avg_winning_trade =
                compute_avg_winning_trade(self.res.gross_profit, self.res.winning_trades)
                    .unwrap_or(0.0);
            self.res.avg_losing_trade =
                compute_avg_losing_trade(self.res.gross_loss, self.res.losing_trades)
                    .unwrap_or(0.0);
            self.res.avg_winning_losing_trade_ratio =
                compute_avg_win_loss_ratio(self.res.avg_winning_trade, self.res.avg_losing_trade)
                    .unwrap_or(0.0);
        }
    }
}
