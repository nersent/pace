use std::cmp::min;

use crate::base::{
    components::{
        common::{
            mean_component::MeanComponent,
            welfords_stdev_component::WelfordsStandardDeviationComponent,
        },
        component_context::ComponentContext,
        component_default::ComponentDefault,
    },
    strategy::orderbook::Order,
};

use super::{
    metrics::{
        max_drawdown_metric::MaxDrawdownMetric,
        profit::{
            compute_avg_losing_trade, compute_avg_trade, compute_avg_win_loss_ratio,
            compute_avg_winning_trade, compute_long_net_profit_ratio,
            compute_percent_profitable_trades, compute_profit_factor,
        },
    },
    orderbook::{OrderBook, OrderBookConfig},
    trade::{compute_fill_size, compute_return, Trade, TradeDirection},
};

pub struct StrategyContextConfig {
    /**
    Enables an additional calculation on bar close, allowing market orders to enter on the same tick the order is placed
    */
    pub on_bar_close: bool,
    pub continous: bool,
    pub initial_capital: f64,
    pub buy_with_equity: bool,
}

impl ComponentDefault for StrategyContextConfig {
    fn default(ctx: ComponentContext) -> Self {
        return StrategyContextConfig {
            on_bar_close: false,
            continous: true,
            initial_capital: 1000.0,
            buy_with_equity: false,
        };
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub struct StrategyMetrics {
    /// The overall profit or loss. In TradingView `strategy.netprofit`
    pub net_profit: f64,
    pub net_profit_percent: f64,
    /// Current unrealized profit or loss for all open positions. In TradingView `strategy.openprofit`
    pub open_profit: f64,
    /// Total value of all completed winning trades. In TradingView `strategy.grossprofit`
    pub gross_profit: f64,
    pub gross_profit_percent: f64,
    /// Total value of all completed losing trades. In TradingView `strategy.grossloss`
    pub gross_loss: f64,
    pub gross_loss_percent: f64,
    /// Current equity (initial capital + net profit + open profit). In TradingView `strategy.equity`
    pub equity: f64,
    /// Net current equity (initial capital + net profit)
    pub net_equity: f64,
    /// Total number of closed tradesIn TradingView `strategy.closedtrades`
    pub closed_trades: usize,
    /// Total number of winning tradesIn TradingView `strategy.wintrades`
    pub winning_trades: usize,
    /// Total number of losing tradesIn TradingView `strategy.losstrades`
    pub losing_trades: usize,
    /// Maximum equity drawdown value for the whole trading interval. In TradingView `strategy.max_drawdown`
    pub max_drawdown: f64,
    pub max_drawdown_percent: f64,
    /// Maximum equity run-up value for the whole trading interval. In TradingView `strategy.max_runup`
    pub max_run_up: f64,
    pub max_run_up_percent: f64,
    /// The amount of money made for every unit of money it lost.
    pub profit_factor: f64,
    /// The percentage of winning trades generated by a strategy.
    pub percent_profitable: f64,
    /// The gross profit divided by the number of winning trades.
    pub avg_winning_trade: f64,
    /// The gross loss divided by the number of losing trades.
    pub avg_losing_trade: f64,
    /// The sum of money gained or lost by the average trade.
    pub avg_trade: f64,
    /// The average value of how many currency units you win for every unit you lose.
    pub avg_winning_losing_trade_ratio: f64,
    /// The overall profit or loss generated by long trades.
    pub long_net_profit: f64,
    pub long_net_profit_percent: f64,
    /// The overall profit or loss generated by short trades.
    pub short_net_profit: f64,
    pub short_net_profit_percent: f64,
    /// Long to short net profit ratio
    pub long_short_net_profit_ratio: f64,
    /// Maximum equity drawdown value for the equity curve. Uses `strategy.equity`
    pub equity_max_drawdown: f64,
    pub equity_max_drawdown_percent: f64,
    /// Maximum drawdown that occured during trades.
    pub intra_trade_max_drawdown: f64,
    pub intra_trade_max_drawdown_percent: f64,
    /// Maximum drawdown that occured on net equity (realized profits)
    pub net_equity_max_drawdown_percent: f64,
}

impl StrategyMetrics {
    pub fn default(initial_capital: f64) -> Self {
        return Self {
            net_profit: 0.0,
            net_profit_percent: 0.0,
            open_profit: 0.0,
            gross_profit: 0.0,
            gross_profit_percent: 0.0,
            gross_loss: 0.0,
            gross_loss_percent: 0.0,
            equity: initial_capital,
            net_equity: initial_capital,
            closed_trades: 0,
            winning_trades: 0,
            losing_trades: 0,
            max_drawdown: 0.0,
            max_drawdown_percent: 0.0,
            max_run_up: 0.0,
            max_run_up_percent: 0.0,
            profit_factor: 1.0,
            percent_profitable: 0.0,
            avg_winning_trade: 0.0,
            avg_losing_trade: 0.0,
            avg_trade: 0.0,
            avg_winning_losing_trade_ratio: 0.0,
            long_net_profit: 0.0,
            long_net_profit_percent: 0.0,
            short_net_profit: 0.0,
            short_net_profit_percent: 0.0,
            long_short_net_profit_ratio: 0.0,
            equity_max_drawdown: 0.0,
            equity_max_drawdown_percent: 0.0,
            intra_trade_max_drawdown: 0.0,
            intra_trade_max_drawdown_percent: 0.0,
            net_equity_max_drawdown_percent: 0.0,
        };
    }
}

pub struct StrategyContext {
    pub config: StrategyContextConfig,
    pub trades: Vec<Trade>,
    ctx: ComponentContext,
    unfilled_trade_direction: Option<TradeDirection>,
    pub metrics: StrategyMetrics,
    trade_fill_size: f64,
    prev_equity: f64,
    pub on_close_trade: bool,
    bar_highest_open_equity: f64,
    bar_lowest_open_equity: f64,
    bar_highest_open_profit: f64,
    bar_lowest_open_profit: f64,
    highest_equity: f64,
    lowest_equity: f64,
    highest_open_equity: f64,
    __highest_equity: f64,
    current_trade_highest_equity: f64,
    current_trade_max_drawdown: f64,
    highest_net_equity: f64,
    // pub equity_curve: f64,
    // pub low_open_profit: f64,
    // pub high_open_profit: f64,
    // pub low_equity: f64,
    // pub high_equity: f64,
}

impl StrategyContext {
    pub fn new(ctx: ComponentContext, config: StrategyContextConfig) -> Self {
        return Self {
            ctx: ctx.clone(),
            trades: Vec::new(),
            unfilled_trade_direction: None,
            metrics: StrategyMetrics::default(config.initial_capital),
            trade_fill_size: 1.0,
            prev_equity: config.initial_capital,
            on_close_trade: false,
            bar_highest_open_equity: config.initial_capital,
            bar_lowest_open_equity: config.initial_capital,
            bar_highest_open_profit: 0.0,
            bar_lowest_open_profit: 0.0,
            highest_equity: config.initial_capital,
            lowest_equity: config.initial_capital,
            highest_open_equity: config.initial_capital,
            __highest_equity: config.initial_capital,
            current_trade_highest_equity: config.initial_capital,
            current_trade_max_drawdown: 0.0,
            highest_net_equity: config.initial_capital,
            config,
        };
    }

    pub fn next(&mut self, direction: Option<TradeDirection>) {
        self.ctx.on_next();

        let ctx = self.ctx.get();
        let tick = ctx.current_tick;
        let open = ctx.open();
        let close = ctx.close();
        let high = ctx.high();
        let low = ctx.low();

        let lowest_price = low
            .unwrap()
            .min(close.unwrap())
            .min(open.unwrap())
            .min(high.unwrap());
        let highest_price = high
            .unwrap()
            .max(close.unwrap())
            .max(open.unwrap())
            .max(low.unwrap());

        if self.config.on_bar_close {
            self.unfilled_trade_direction = direction;
        }

        let mut close_trade = false;
        let mut create_new_trade = false;
        let mut calculate_open_profit = true;

        if let Some(unfilled_trade_direction) = self.unfilled_trade_direction {
            let orderbook_price = if self.config.on_bar_close {
                close
            } else {
                open
            };

            if let Some(last_trade) = self.trades.last_mut() {
                let is_same_direction = last_trade.direction == unfilled_trade_direction;

                close_trade = !is_same_direction && !last_trade.is_closed;

                if self.config.continous {
                    create_new_trade = !is_same_direction && close_trade;
                } else {
                    create_new_trade = last_trade.is_closed
                        && (is_same_direction || !is_same_direction && !close_trade);

                    if close_trade {
                        calculate_open_profit = false;
                    }
                }

                if close_trade {
                    last_trade.exit_price = orderbook_price;
                    last_trade.exit_tick = Some(tick);
                    last_trade.is_closed = true;

                    let trade_pnl =
                        last_trade.pnl(self.trade_fill_size, last_trade.exit_price.unwrap());

                    self.metrics.net_profit += trade_pnl;
                    self.metrics.open_profit = 0.0;
                    self.metrics.closed_trades += 1;
                    self.metrics.net_equity = self.config.initial_capital + self.metrics.net_profit;

                    self.highest_net_equity =
                        f64::max(self.metrics.net_equity, self.highest_net_equity);
                    self.metrics.net_equity_max_drawdown_percent = f64::min(
                        self.metrics.net_equity / self.highest_net_equity - 1.0,
                        self.metrics.net_equity_max_drawdown_percent,
                    );

                    if last_trade.direction == TradeDirection::Long {
                        self.metrics.long_net_profit += trade_pnl;
                    } else {
                        self.metrics.short_net_profit += trade_pnl;
                    }

                    self.metrics.long_net_profit_percent =
                        self.metrics.long_net_profit / self.config.initial_capital;
                    self.metrics.short_net_profit_percent =
                        self.metrics.short_net_profit / self.config.initial_capital;

                    self.metrics.long_short_net_profit_ratio = compute_long_net_profit_ratio(
                        self.metrics.long_net_profit,
                        self.metrics.short_net_profit,
                    );

                    if trade_pnl < 0.0 {
                        self.metrics.gross_loss += trade_pnl.abs();
                        self.metrics.losing_trades += 1;
                    } else if trade_pnl > 0.0 {
                        self.metrics.gross_profit += trade_pnl;
                        self.metrics.winning_trades += 1;
                    }

                    let open_profit = last_trade.pnl(self.trade_fill_size, close.unwrap());

                    let equity = self.config.initial_capital + self.metrics.net_profit;

                    self.current_trade_highest_equity = equity;

                    self.lowest_equity = f64::min(self.lowest_equity, equity);
                    self.highest_equity = f64::max(self.highest_equity, equity);

                    let intra_trade_max_drawdown_percent =
                        self.current_trade_max_drawdown / last_trade.entry_price.unwrap();

                    self.metrics.intra_trade_max_drawdown_percent = f64::max(
                        intra_trade_max_drawdown_percent,
                        self.metrics.intra_trade_max_drawdown_percent,
                    );

                    self.current_trade_max_drawdown = 0.0
                }
            } else {
                create_new_trade = true;
            }

            if create_new_trade {
                if self.config.buy_with_equity {
                    let mut last_trade = self.trades.last_mut();
                    let prev_equity = self.metrics.equity;
                    let mut equity = self.metrics.equity;

                    if let Some(last_trade) = &mut last_trade {
                        let open_profit = last_trade.pnl(self.trade_fill_size, close.unwrap());
                        equity = self.config.initial_capital
                            + self.metrics.net_profit
                            + self.metrics.open_profit;
                    }

                    self.trade_fill_size = compute_fill_size(equity, orderbook_price.unwrap());
                }

                let mut trade = Trade::new(unfilled_trade_direction);
                trade.entry_price = orderbook_price;
                trade.entry_tick = Some(tick);
                self.trades.push(trade);
            }

            self.unfilled_trade_direction = None;
        }

        if !self.config.on_bar_close {
            self.unfilled_trade_direction = direction;
        }

        let mut last_trade = self.trades.last_mut();

        if let Some(last_trade) = &mut last_trade {
            if calculate_open_profit && !last_trade.is_closed {
                self.metrics.open_profit = last_trade.pnl(self.trade_fill_size, close.unwrap());

                let low_price = if last_trade.direction == TradeDirection::Long {
                    lowest_price
                } else {
                    highest_price
                };

                let high_price = if last_trade.direction == TradeDirection::Long {
                    highest_price
                } else {
                    lowest_price
                };

                self.bar_lowest_open_profit = last_trade.pnl(self.trade_fill_size, low_price);
                self.bar_highest_open_profit = last_trade.pnl(self.trade_fill_size, high_price);
            }
        }

        self.on_close_trade = close_trade;

        self.metrics.equity =
            self.config.initial_capital + self.metrics.net_profit + self.metrics.open_profit;

        self.__highest_equity = f64::max(self.__highest_equity, self.metrics.equity);

        self.bar_lowest_open_equity =
            self.config.initial_capital + self.metrics.net_profit + self.bar_lowest_open_profit;

        self.bar_highest_open_equity =
            self.config.initial_capital + self.metrics.net_profit + self.bar_highest_open_profit;

        self.highest_open_equity = f64::max(self.highest_open_equity, self.bar_highest_open_equity);

        self.metrics.max_drawdown = f64::max(
            self.highest_equity - self.bar_lowest_open_equity,
            self.metrics.max_drawdown,
        );
        self.metrics.max_drawdown_percent = self.metrics.max_drawdown / self.highest_equity;

        self.metrics.max_run_up = f64::max(
            self.bar_highest_open_equity - self.lowest_equity,
            self.metrics.max_run_up,
        );
        self.metrics.max_run_up_percent = self.metrics.max_run_up / self.highest_open_equity;

        self.metrics.equity_max_drawdown_percent = f64::min(
            (self.metrics.equity / self.__highest_equity - 1.0),
            self.metrics.equity_max_drawdown_percent,
        );

        self.current_trade_max_drawdown = f64::max(
            self.current_trade_highest_equity - self.bar_lowest_open_equity,
            self.current_trade_max_drawdown,
        );

        self.metrics.net_profit_percent = self.metrics.net_profit / self.config.initial_capital;
        self.metrics.gross_profit_percent = self.metrics.gross_profit / self.config.initial_capital;
        self.metrics.gross_loss_percent = self.metrics.gross_loss / self.config.initial_capital;
        self.metrics.profit_factor =
            compute_profit_factor(self.metrics.gross_profit, self.metrics.gross_loss);
        self.metrics.percent_profitable = compute_percent_profitable_trades(
            self.metrics.winning_trades,
            self.metrics.closed_trades,
        );

        self.metrics.avg_trade =
            compute_avg_trade(self.metrics.net_profit, self.metrics.closed_trades);
        self.metrics.avg_winning_trade =
            compute_avg_winning_trade(self.metrics.gross_profit, self.metrics.winning_trades);
        self.metrics.avg_losing_trade =
            compute_avg_losing_trade(self.metrics.gross_loss, self.metrics.losing_trades);
        self.metrics.avg_winning_losing_trade_ratio = compute_avg_win_loss_ratio(
            self.metrics.avg_winning_trade,
            self.metrics.avg_losing_trade,
        );
    }
}
